import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest'
import supertest from 'supertest'
import {
    setupTestServer,
    teardownTestServer,
    setupTestDatabase,
    teardownTestDatabase,
    cleanupTestDatabase,
    createApiClient
} from '../api/setup'
import { createAuthHelpers, ApiAuthHelpers } from '../api/auth-helpers'

describe('Security Vulnerability Tests', () => {
    let apiClient: supertest.SuperTest<supertest.Test>
    let testDb: any
    let authHelpers: ApiAuthHelpers

    beforeAll(async () => {
        await setupTestServer()
        testDb = await setupTestDatabase()
        apiClient = createApiClient()
        authHelpers = createAuthHelpers(apiClient, testDb)
    })

    afterAll(async () => {
        await teardownTestDatabase()
        await teardownTestServer()
    })

    beforeEach(async () => {
        await cleanupTestDatabase()
    })

    afterEach(async () => {
        await authHelpers.cleanupTestUsers()
    })

    describe('SQL Injection Prevention Tests', () => {
        test('should prevent SQL injection in authentication endpoints', async () => {
            const sqlInjectionPayloads = [
                "'; DROP TABLE users; --",
                "' OR '1'='1' --",
                "' UNION SELECT * FROM users --",
                "'; UPDATE users SET role = 'admin' WHERE id = 1; --",
                "' OR 1=1 LIMIT 1 OFFSET 0 --",
                "'; INSERT INTO users (username, password) VALUES ('hacker', 'password'); --"
            ]

            for (const payload of sqlInjectionPayloads) {
                const response = await apiClient
                    .post('/api/v1/auth/login')
                    .send({
                        identifier: payload,
                        password: 'password123'
                    })

                // Should not crash and should return appropriate error
                expect(response.status).toBeGreaterThanOrEqual(400)
                expect(response.body.success).toBe(false)

                // Verify database integrity is maintained
                const userCount = testDb.prepare('SELECT COUNT(*) as count FROM users').get()
                expect(userCount).toBeDefined()
                expect(typeof userCount.count).toBe('number')
            }
        })

        test('should prevent SQL injection in parcel endpoints', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const sqlInjectionPayloads = [
                "'; DROP TABLE parcelles; --",
                "' OR '1'='1' --",
                "'; UPDATE parcelles SET prix_achat = 0; --",
                "' UNION SELECT * FROM users --"
            ]

            for (const payload of sqlInjectionPayloads) {
                // Test GET endpoint with malicious query parameter
                const getResponse = await apiClient
                    .get(`/api/v1/parcelles?search=${encodeURIComponent(payload)}`)
                    .set('Cookie', `session_id=${session.id}`)

                expect([200, 400, 500]).toContain(getResponse.status)

                // Test POST endpoint with malicious data
                const postResponse = await apiClient
                    .post('/api/v1/parcelles')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        numero: payload,
                        transporteur: 'Test Transporteur',
                        poids: 100,
                        prix_achat: 50
                    })

                expect([200, 400, 500]).toContain(postResponse.status)

                // Verify database integrity
                const parcelCount = testDb.prepare('SELECT COUNT(*) as count FROM parcelles').get()
                expect(parcelCount).toBeDefined()
            }
        })

        test('should prevent SQL injection in product endpoints', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const sqlInjectionPayloads = [
                "'; DROP TABLE produits; --",
                "' OR 1=1 --",
                "'; UPDATE produits SET prix = 0; --"
            ]

            for (const payload of sqlInjectionPayloads) {
                const response = await apiClient
                    .post('/api/v1/produits')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        nom: payload,
                        prix: 100,
                        quantite: 1,
                        parcelle_id: 'test-parcelle'
                    })

                expect([200, 400, 500]).toContain(response.status)

                // Verify database integrity
                const productCount = testDb.prepare('SELECT COUNT(*) as count FROM produits').get()
                expect(productCount).toBeDefined()
            }
        })

        test('should prevent SQL injection in search endpoints', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const sqlInjectionPayloads = [
                "'; DROP TABLE search_history; --",
                "' UNION SELECT password_hash FROM users --",
                "'; DELETE FROM sessions; --"
            ]

            for (const payload of sqlInjectionPayloads) {
                const response = await apiClient
                    .get(`/api/v1/search/global?q=${encodeURIComponent(payload)}`)
                    .set('Cookie', `session_id=${session.id}`)

                expect([200, 400, 500]).toContain(response.status)

                // Verify critical tables still exist
                const userCount = testDb.prepare('SELECT COUNT(*) as count FROM users').get()
                const sessionCount = testDb.prepare('SELECT COUNT(*) as count FROM sessions').get()
                expect(userCount).toBeDefined()
                expect(sessionCount).toBeDefined()
            }
        })
    })

    describe('XSS Attack Prevention Tests', () => {
        test('should prevent XSS in user input fields', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const xssPayloads = [
                '<script>alert("xss")</script>',
                '<img src="x" onerror="alert(\'xss\')" />',
                '<svg onload="alert(\'xss\')" />',
                'javascript:alert("xss")',
                '<iframe src="javascript:alert(\'xss\')"></iframe>',
                '<body onload="alert(\'xss\')" />',
                '<div onclick="alert(\'xss\')">Click me</div>',
                '<input type="text" value="<script>alert(\'xss\')</script>" />'
            ]

            for (const payload of xssPayloads) {
                // Test profile update with XSS payload
                const profileResponse = await apiClient
                    .post('/api/v1/profile/update')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        username: payload,
                        email: 'test@example.com',
                        bio: payload,
                        theme: 'light',
                        language: 'fr'
                    })

                if (profileResponse.status === 200) {
                    // If update succeeds, verify data is sanitized
                    const updatedUser = testDb.prepare('SELECT * FROM users WHERE id = ?').get(testUser.id)
                    expect(updatedUser.username).not.toContain('<script>')
                    expect(updatedUser.bio).not.toContain('onerror')
                    expect(updatedUser.bio).not.toContain('onload')
                    expect(updatedUser.bio).not.toContain('javascript:')
                } else {
                    // If rejected, should be due to validation
                    expect(profileResponse.status).toBeGreaterThanOrEqual(400)
                    expect(profileResponse.body.success).toBe(false)
                }

                // Test parcel creation with XSS payload
                const parcelResponse = await apiClient
                    .post('/api/v1/parcelles')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        numero: payload,
                        transporteur: payload,
                        poids: 100,
                        prix_achat: 50
                    })

                // Response should not contain unescaped script tags
                const responseText = JSON.stringify(parcelResponse.body)
                expect(responseText).not.toContain('<script>')
                expect(responseText).not.toContain('onerror')
                expect(responseText).not.toContain('javascript:')
            }
        })

        test('should sanitize XSS in API responses', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            // Create data with potential XSS content
            const xssContent = '<script>alert("stored-xss")</script>'

            const response = await apiClient
                .post('/api/v1/parcelles')
                .set('Cookie', `session_id=${session.id}`)
                .send({
                    numero: 'TEST-001',
                    transporteur: xssContent,
                    poids: 100,
                    prix_achat: 50
                })

            // Get the data back
            const getResponse = await apiClient
                .get('/api/v1/parcelles')
                .set('Cookie', `session_id=${session.id}`)

            // Response should not contain executable script tags
            const responseText = JSON.stringify(getResponse.body)
            expect(responseText).not.toContain('<script>')
            expect(responseText).not.toContain('alert(')
        })

        test('should prevent XSS in error messages', async () => {
            const xssPayload = '<script>alert("xss-error")</script>'

            const response = await apiClient
                .post('/api/v1/auth/login')
                .send({
                    identifier: xssPayload,
                    password: 'password123'
                })

            // Error response should not contain unescaped script tags
            const responseText = JSON.stringify(response.body)
            expect(responseText).not.toContain('<script>')
            expect(responseText).not.toContain('alert(')
        })
    })

    describe('CSRF Protection Validation Tests', () => {
        test('should validate CSRF protection for state-changing operations', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            // Test CSRF protection on profile update
            const profileResponse = await apiClient
                .post('/api/v1/profile/update')
                .set('Cookie', `session_id=${session.id}`)
                .set('Origin', 'https://malicious-site.com')
                .set('Referer', 'https://malicious-site.com/attack')
                .send({
                    username: 'csrf-test',
                    email: 'csrf@example.com',
                    theme: 'light',
                    language: 'fr'
                })

            // Should either require CSRF token, validate origin, or handle gracefully
            expect([200, 403, 400]).toContain(profileResponse.status)

            // Test CSRF protection on parcel creation
            const parcelResponse = await apiClient
                .post('/api/v1/parcelles')
                .set('Cookie', `session_id=${session.id}`)
                .set('Origin', 'https://evil.com')
                .send({
                    numero: 'CSRF-001',
                    transporteur: 'Test',
                    poids: 100,
                    prix_achat: 50
                })

            expect([200, 403, 400]).toContain(parcelResponse.status)
        })

        test('should validate same-origin policy enforcement', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const maliciousOrigins = [
                'https://evil.com',
                'http://malicious-site.com',
                'https://logistix-fake.com',
                'javascript:alert("xss")'
            ]

            for (const origin of maliciousOrigins) {
                const response = await apiClient
                    .post('/api/v1/produits')
                    .set('Cookie', `session_id=${session.id}`)
                    .set('Origin', origin)
                    .send({
                        nom: 'Test Product',
                        prix: 100,
                        quantite: 1,
                        parcelle_id: 'test-parcelle'
                    })

                // Should either accept (if no CSRF protection) or reject with 403
                expect([200, 403, 400]).toContain(response.status)
            }
        })
    })

    describe('Authentication Bypass Attempts Tests', () => {
        test('should prevent session token manipulation', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const manipulatedTokens = [
                session.id + 'extra',
                session.id.slice(0, -1) + 'x',
                session.id.replace(/[0-9]/g, '0'),
                'admin-session-' + session.id,
                btoa(session.id), // Base64 encoded
                session.id.split('').reverse().join('') // Reversed
            ]

            for (const token of manipulatedTokens) {
                const response = await apiClient
                    .get('/api/v1/auth/me')
                    .set('Cookie', `session_id=${token}`)

                expect(response.status).toBe(401)
                expect(response.body.success).toBe(false)
            }
        })

        test('should prevent privilege escalation attempts', async () => {
            const testUser = await authHelpers.createTestUser({ role: 'user' })
            const session = await authHelpers.createTestSession(testUser.id)

            // Attempt to access admin endpoints
            const adminEndpoints = [
                '/api/v1/admin/database/overview',
                '/api/v1/admin/system/health',
                '/api/v1/admin/users',
                '/api/v1/admin/logs'
            ]

            for (const endpoint of adminEndpoints) {
                const response = await apiClient
                    .get(endpoint)
                    .set('Cookie', `session_id=${session.id}`)

                // Should deny access for non-admin users
                expect([401, 403, 404]).toContain(response.status)
            }
        })

        test('should prevent JWT token manipulation if used', async () => {
            // Test various JWT manipulation attempts
            const maliciousJWTs = [
                'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFkbWluIiwiaWF0IjoxNTE2MjM5MDIyfQ.',
                'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbiIsInJvbGUiOiJhZG1pbiIsImlhdCI6MTUxNjIzOTAyMn0.invalid',
                'Bearer admin-token',
                'null',
                'undefined'
            ]

            for (const jwt of maliciousJWTs) {
                const response = await apiClient
                    .get('/api/v1/auth/me')
                    .set('Authorization', `Bearer ${jwt}`)

                expect([401, 400]).toContain(response.status)
            }
        })

        test('should prevent password reset token manipulation', async () => {
            // Test password reset token manipulation
            const maliciousTokens = [
                'reset-token-admin',
                '00000000-0000-0000-0000-000000000000',
                'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
                '../../../etc/passwd',
                'token"; DROP TABLE users; --'
            ]

            for (const token of maliciousTokens) {
                const response = await apiClient
                    .post('/api/v1/auth/reset-password')
                    .send({
                        token: token,
                        password: 'newpassword123'
                    })

                expect([400, 401, 404]).toContain(response.status)
                expect(response.body.success).toBe(false)
            }
        })
    })

    describe('Authorization Boundary Enforcement Tests', () => {
        test('should enforce user data access boundaries', async () => {
            const user1 = await authHelpers.createTestUser({ username: 'user1', email: 'user1@example.com' })
            const user2 = await authHelpers.createTestUser({ username: 'user2', email: 'user2@example.com' })
            const session1 = await authHelpers.createTestSession(user1.id)
            const session2 = await authHelpers.createTestSession(user2.id)

            // User1 creates a parcel
            const parcelResponse = await apiClient
                .post('/api/v1/parcelles')
                .set('Cookie', `session_id=${session1.id}`)
                .send({
                    numero: 'USER1-001',
                    transporteur: 'Test',
                    poids: 100,
                    prix_achat: 50
                })

            if (parcelResponse.status === 200 || parcelResponse.status === 201) {
                const parcelId = parcelResponse.body.id || parcelResponse.body.data?.id

                // User2 should not be able to access User1's parcel
                const accessResponse = await apiClient
                    .get(`/api/v1/parcelles/${parcelId}`)
                    .set('Cookie', `session_id=${session2.id}`)

                expect([401, 403, 404]).toContain(accessResponse.status)

                // User2 should not be able to modify User1's parcel
                const modifyResponse = await apiClient
                    .put(`/api/v1/parcelles/${parcelId}`)
                    .set('Cookie', `session_id=${session2.id}`)
                    .send({
                        numero: 'HACKED-001',
                        transporteur: 'Hacker',
                        poids: 999,
                        prix_achat: 1
                    })

                expect([401, 403, 404]).toContain(modifyResponse.status)
            }
        })

        test('should enforce role-based access control', async () => {
            const regularUser = await authHelpers.createTestUser({ role: 'user' })
            const adminUser = await authHelpers.createTestUser({ role: 'admin' })
            const userSession = await authHelpers.createTestSession(regularUser.id)
            const adminSession = await authHelpers.createTestSession(adminUser.id)

            // Test admin-only endpoints
            const adminEndpoints = [
                { method: 'get', path: '/api/v1/admin/database/overview' },
                { method: 'get', path: '/api/v1/admin/system/health' },
                { method: 'post', path: '/api/v1/admin/maintenance' },
                { method: 'get', path: '/api/v1/admin/logs' }
            ]

            for (const endpoint of adminEndpoints) {
                // Regular user should be denied
                const userResponse = await apiClient[endpoint.method](endpoint.path)
                    .set('Cookie', `session_id=${userSession.id}`)

                expect([401, 403, 404]).toContain(userResponse.status)

                // Admin user should have access (or at least not be denied due to role)
                const adminResponse = await apiClient[endpoint.method](endpoint.path)
                    .set('Cookie', `session_id=${adminSession.id}`)

                expect([200, 404, 500]).toContain(adminResponse.status) // 404/500 if endpoint doesn't exist yet
            }
        })

        test('should prevent horizontal privilege escalation', async () => {
            const user1 = await authHelpers.createTestUser({ username: 'user1' })
            const user2 = await authHelpers.createTestUser({ username: 'user2' })
            const session1 = await authHelpers.createTestSession(user1.id)

            // User1 tries to access User2's profile
            const profileResponse = await apiClient
                .get(`/api/v1/users/${user2.id}/profile`)
                .set('Cookie', `session_id=${session1.id}`)

            expect([401, 403, 404]).toContain(profileResponse.status)

            // User1 tries to update User2's profile
            const updateResponse = await apiClient
                .post(`/api/v1/users/${user2.id}/profile`)
                .set('Cookie', `session_id=${session1.id}`)
                .send({
                    username: 'hacked-user2',
                    email: 'hacked@example.com'
                })

            expect([401, 403, 404]).toContain(updateResponse.status)
        })

        test('should prevent vertical privilege escalation', async () => {
            const regularUser = await authHelpers.createTestUser({ role: 'user' })
            const session = await authHelpers.createTestSession(regularUser.id)

            // Attempt to escalate privileges through profile update
            const escalationAttempts = [
                { role: 'admin' },
                { permissions: ['admin', 'super_user'] },
                { is_admin: true },
                { admin: true },
                { user_type: 'admin' }
            ]

            for (const attempt of escalationAttempts) {
                const response = await apiClient
                    .post('/api/v1/profile/update')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        username: 'regular-user',
                        email: 'user@example.com',
                        theme: 'light',
                        language: 'fr',
                        ...attempt
                    })

                // Should either ignore the privilege fields or reject the request
                if (response.status === 200) {
                    // Verify user role wasn't changed
                    const updatedUser = testDb.prepare('SELECT role FROM users WHERE id = ?').get(regularUser.id)
                    expect(updatedUser.role).not.toBe('admin')
                } else {
                    expect([400, 403]).toContain(response.status)
                }
            }
        })
    })

    describe('Input Validation and Sanitization Tests', () => {
        test('should validate and sanitize file upload inputs', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const maliciousFileNames = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\config\\sam',
                'file.php',
                'script.js',
                '<script>alert("xss")</script>.txt',
                'file"; rm -rf /; echo "',
                'file.exe',
                'file.bat'
            ]

            for (const fileName of maliciousFileNames) {
                const response = await apiClient
                    .post('/api/v1/upload')
                    .set('Cookie', `session_id=${session.id}`)
                    .attach('file', Buffer.from('test content'), fileName)

                // Should either reject malicious files or sanitize the filename
                if (response.status === 200) {
                    expect(response.body.filename).not.toContain('../')
                    expect(response.body.filename).not.toContain('<script>')
                    expect(response.body.filename).not.toContain(';')
                } else {
                    expect([400, 403]).toContain(response.status)
                }
            }
        })

        test('should validate numeric inputs for boundary conditions', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const maliciousNumericInputs = [
                { poids: -1 },
                { poids: 0 },
                { poids: Number.MAX_SAFE_INTEGER },
                { poids: Number.POSITIVE_INFINITY },
                { poids: Number.NaN },
                { prix_achat: -999999 },
                { prix_achat: Number.MAX_VALUE },
                { quantite: -1 },
                { quantite: 0.5 } // Should be integer
            ]

            for (const input of maliciousNumericInputs) {
                const response = await apiClient
                    .post('/api/v1/parcelles')
                    .set('Cookie', `session_id=${session.id}`)
                    .send({
                        numero: 'TEST-001',
                        transporteur: 'Test',
                        poids: 100,
                        prix_achat: 50,
                        ...input
                    })

                // Should validate and reject invalid numeric inputs
                if (Object.values(input)[0] < 0 || !Number.isFinite(Object.values(input)[0])) {
                    expect([400, 422]).toContain(response.status)
                    expect(response.body.success).toBe(false)
                }
            }
        })

        test('should validate string length limits', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const longString = 'a'.repeat(10000) // Very long string
            const emptyString = ''

            const stringInputTests = [
                { field: 'numero', value: longString },
                { field: 'transporteur', value: longString },
                { field: 'numero', value: emptyString },
                { field: 'transporteur', value: emptyString }
            ]

            for (const test of stringInputTests) {
                const parcelData = {
                    numero: 'TEST-001',
                    transporteur: 'Test',
                    poids: 100,
                    prix_achat: 50
                }
                parcelData[test.field] = test.value

                const response = await apiClient
                    .post('/api/v1/parcelles')
                    .set('Cookie', `session_id=${session.id}`)
                    .send(parcelData)

                // Should validate string lengths
                if (test.value.length > 255 || test.value.length === 0) {
                    expect([400, 422]).toContain(response.status)
                }
            }
        })
    })

    describe('Rate Limiting and DoS Protection Tests', () => {
        test('should implement rate limiting for authentication attempts', async () => {
            const attempts: number[] = []
            const testEmail = 'ratelimit@example.com'

            // Make multiple rapid authentication attempts
            for (let i = 0; i < 20; i++) {
                try {
                    const response = await apiClient
                        .post('/api/v1/auth/login')
                        .send({
                            identifier: testEmail,
                            password: 'wrongpassword'
                        })

                    attempts.push(response.status)
                } catch (error) {
                    attempts.push(500)
                }
            }

            // Should eventually rate limit (429) or continue to reject (401)
            const hasRateLimit = attempts.some(status => status === 429)
            const allUnauthorized = attempts.every(status => status === 401)

            expect(hasRateLimit || allUnauthorized).toBe(true)
        })

        test('should implement rate limiting for API endpoints', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const responses: number[] = []

            // Make rapid requests to API endpoint
            for (let i = 0; i < 50; i++) {
                try {
                    const response = await apiClient
                        .get('/api/v1/parcelles')
                        .set('Cookie', `session_id=${session.id}`)

                    responses.push(response.status)
                } catch (error) {
                    responses.push(500)
                }
            }

            // Should either rate limit or handle all requests
            const hasRateLimit = responses.some(status => status === 429)
            const allSuccessful = responses.every(status => status === 200)

            expect(hasRateLimit || allSuccessful).toBe(true)
        })

        test('should protect against large payload attacks', async () => {
            const testUser = await authHelpers.createTestUser()
            const session = await authHelpers.createTestSession(testUser.id)

            const largePayload = {
                numero: 'a'.repeat(100000),
                transporteur: 'b'.repeat(100000),
                description: 'c'.repeat(1000000),
                poids: 100,
                prix_achat: 50
            }

            const response = await apiClient
                .post('/api/v1/parcelles')
                .set('Cookie', `session_id=${session.id}`)
                .send(largePayload)

            // Should reject overly large payloads
            expect([400, 413, 422]).toContain(response.status)
        })
    })

    describe('Session Security Tests', () => {
        test('should implement secure session management', async () => {
            const testUser = await authHelpers.createTestUser()

            const loginResponse = await apiClient
                .post('/api/v1/auth/login')
                .send({
                    identifier: 'admin', // Using admin login as per current system
                    password: 'password123'
                })
                .expect(200)

            const cookies = loginResponse.headers['set-cookie'] as string[]
            const sessionCookie = cookies.find((cookie: string) => cookie.includes('session_id'))

            expect(sessionCookie).toBeDefined()

            // Check for secure cookie attributes
            expect(sessionCookie).toMatch(/HttpOnly/i)
            // In production, should also have Secure flag
            // expect(sessionCookie).toMatch(/Secure/i)
        })

        test('should prevent session fixation attacks', async () => {
            // Attempt to set a predetermined session ID
            const fixedSessionId = 'fixed-session-12345'

            const response = await apiClient
                .post('/api/v1/auth/login')
                .set('Cookie', `session_id=${fixedSessionId}`)
                .send({
                    identifier: 'admin',
                    password: 'password123'
                })

            if (response.status === 200) {
                // Should generate a new session ID, not use the fixed one
                const cookies = response.headers['set-cookie'] as string[]
                const sessionCookie = cookies.find((cookie: string) => cookie.includes('session_id'))

                if (sessionCookie) {
                    const newSessionId = sessionCookie.split('session_id=')[1].split(';')[0]
                    expect(newSessionId).not.toBe(fixedSessionId)
                }
            }
        })

        test('should handle concurrent session limits', async () => {
            const testUser = await authHelpers.createTestUser()

            // Create multiple sessions for the same user
            const sessions = []
            for (let i = 0; i < 10; i++) {
                const session = await authHelpers.createTestSession(testUser.id)
                sessions.push(session)
            }

            // Verify all sessions or check if there's a limit
            let validSessions = 0
            for (const session of sessions) {
                const response = await apiClient
                    .get('/api/v1/auth/me')
                    .set('Cookie', `session_id=${session.id}`)

                if (response.status === 200) {
                    validSessions++
                }
            }

            // Should either allow all sessions or enforce a reasonable limit
            expect(validSessions).toBeGreaterThan(0)
            expect(validSessions).toBeLessThanOrEqual(10)
        })
    })
})